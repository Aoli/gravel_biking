/// Route Management Mixin for Route Editing Operations
///
/// Provides comprehensive route editing functionality including point management,
/// undo/redo operations, distance calculations, and route state management.
library;

import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:latlong2/latlong.dart';

import '../models/route_state_snapshot.dart';
import '../providers/ui_providers.dart';

/// Mixin providing comprehensive route management operations
///
/// This mixin encapsulates all route editing functionality including:
/// - Point addition, insertion, deletion, and movement
/// - Loop closure management
/// - Undo/redo system with full state snapshots
/// - Distance and segment calculations
/// - Route clearing and validation
///
/// **Features:**
/// - Up to 50 undo states with automatic cleanup
/// - Comprehensive state preservation for all operations
/// - Integration with Riverpod state management
/// - Automatic distance marker regeneration
mixin RouteManagementMixin<T extends ConsumerStatefulWidget>
    on ConsumerState<T> {
  // Route state management
  final List<LatLng> routePoints = [];
  final List<double> segmentMeters = [];
  final List<LatLng> distanceMarkers = [];

  // Undo system
  final List<RouteStateSnapshot> undoHistory = [];
  static const int maxUndoHistory = 50;

  // Distance calculation utility
  final Distance _distance = Distance();

  /// Save current state for undo functionality
  ///
  /// Creates a snapshot of the current route state that can be restored later.
  /// Automatically manages undo history size to prevent memory issues.
  void saveStateForUndo() {
    final currentState = RouteStateSnapshot.fromCurrent(
      routePoints: routePoints,
      loopClosed: ref.read(loopClosedProvider),
      showDistanceMarkers: ref.read(distanceMarkersProvider),
      distanceMarkers: distanceMarkers,
    );

    undoHistory.add(currentState);

    // Limit undo history size
    while (undoHistory.length > maxUndoHistory) {
      undoHistory.removeAt(0);
    }
  }

  /// Undo the last edit operation
  ///
  /// Restores the route to the previous state, including all route points,
  /// loop closure status, and distance markers.
  void undoLastEdit() {
    if (undoHistory.isEmpty) return;

    final previousState = undoHistory.removeLast();

    setState(() {
      routePoints.clear();
      routePoints.addAll(previousState.routePoints);
      ref
          .read(routeNotifierProvider.notifier)
          .setLoopClosed(previousState.loopClosed);
      ref.read(distanceMarkersProvider.notifier).state =
          previousState.showDistanceMarkers;
      distanceMarkers.clear();
      distanceMarkers.addAll(previousState.distanceMarkers);
      ref.read(editingIndexProvider.notifier).state = null;
      recomputeSegments();
    });
  }

  /// Clear all route data
  ///
  /// Removes all route points, segments, and markers. Resets all related state
  /// to initial values.
  void clearRoute() {
    if (routePoints.isEmpty && segmentMeters.isEmpty) return;

    setState(() {
      routePoints.clear();
      distanceMarkers.clear();
      segmentMeters.clear();
      ref.read(routeNotifierProvider.notifier).setLoopClosed(false);
      ref.read(editingIndexProvider.notifier).state = null;
    });
  }

  /// Add a point between two existing points
  ///
  /// Inserts a new point at the specified position in the route.
  /// Automatically saves state for undo and recalculates segments.
  void addPointBetween(int beforeIndex, int afterIndex, LatLng midpoint) {
    saveStateForUndo();

    setState(() {
      final insertIndex = beforeIndex + 1;
      routePoints.insert(insertIndex, midpoint);
      distanceMarkers.clear();
      recomputeSegments();
      autoGenerateDistanceMarkers();
    });
  }

  /// Delete a route point at the specified index
  ///
  /// Removes the point and automatically handles loop closure validation.
  /// If fewer than 3 points remain, the loop is automatically opened.
  void deletePoint(int index) {
    if (index < 0 || index >= routePoints.length) return;

    saveStateForUndo();

    setState(() {
      routePoints.removeAt(index);
      distanceMarkers.clear();

      if (routePoints.length < 3) {
        ref.read(routeNotifierProvider.notifier).setLoopClosed(false);
      }

      final currentEditingIndex = ref.read(editingIndexProvider);
      if (currentEditingIndex != null) {
        if (routePoints.isEmpty) {
          ref.read(editingIndexProvider.notifier).state = null;
        } else if (index == currentEditingIndex) {
          ref.read(editingIndexProvider.notifier).state = null;
        } else if (index < currentEditingIndex) {
          ref.read(editingIndexProvider.notifier).state =
              currentEditingIndex - 1;
        }
      }

      recomputeSegments();
      autoGenerateDistanceMarkers();
    });
  }

  /// Move a route point to a new position
  ///
  /// Updates the coordinates of an existing point and recalculates
  /// all dependent data (segments, distances, markers).
  void movePoint(int index, LatLng newPosition) {
    if (index < 0 || index >= routePoints.length) return;

    saveStateForUndo();

    setState(() {
      routePoints[index] = newPosition;
      distanceMarkers.clear();
      recomputeSegments();
      autoGenerateDistanceMarkers();
    });
  }

  /// Toggle the loop closure state
  ///
  /// Opens or closes the route loop. Requires at least 3 points to close a loop.
  /// Automatically regenerates distance markers to include/exclude closing segment.
  void toggleLoop() {
    if (routePoints.length < 3) return;

    saveStateForUndo();

    setState(() {
      ref.read(routeNotifierProvider.notifier).toggleLoop();
      recomputeSegments();
      autoGenerateDistanceMarkers();
    });
  }

  /// Recompute route segments and distances
  ///
  /// Recalculates all segment distances based on current route points
  /// and loop closure state.
  void recomputeSegments() {
    segmentMeters
      ..clear()
      ..addAll(computeSegments(routePoints, ref.read(loopClosedProvider)));
  }

  /// Compute segment distances for given route points
  ///
  /// Calculates distances between consecutive points using haversine formula.
  /// Includes closing segment distance if loop is closed.
  List<double> computeSegments(List<LatLng> points, bool loopClosed) {
    if (points.length < 2) return [];

    final segments = <double>[];
    for (int i = 1; i < points.length; i++) {
      segments.add(_distance.as(LengthUnit.Meter, points[i - 1], points[i]));
    }

    // Add closing segment if loop is closed
    if (loopClosed && points.length >= 3) {
      segments.add(_distance.as(LengthUnit.Meter, points.last, points.first));
    }

    return segments;
  }

  /// Auto-generate distance markers for the current route
  ///
  /// Creates distance markers at regular intervals along the route based on
  /// the current distance interval setting.
  void autoGenerateDistanceMarkers() {
    if (!ref.read(distanceMarkersProvider) || routePoints.length < 2) {
      distanceMarkers.clear();
      return;
    }

    final interval = ref.read(distanceIntervalProvider);
    distanceMarkers
      ..clear()
      ..addAll(
        generateDistanceMarkers(
          routePoints,
          ref.read(loopClosedProvider),
          interval,
        ),
      );
  }

  /// Generate distance markers for given route parameters
  ///
  /// Calculates marker positions at specified intervals along the route.
  /// Handles both open routes and closed loops with appropriate segment handling.
  List<LatLng> generateDistanceMarkers(
    List<LatLng> points,
    bool loopClosed,
    double intervalMeters,
  ) {
    if (points.length < 2 || intervalMeters <= 0) return [];

    final markers = <LatLng>[];
    double currentDistance = 0.0;

    // Process main route segments
    for (int i = 1; i < points.length; i++) {
      final segmentDistance = _distance.as(
        LengthUnit.Meter,
        points[i - 1],
        points[i],
      );
      final segmentEnd = currentDistance + segmentDistance;

      // Check for markers within this segment
      while (currentDistance + intervalMeters <= segmentEnd) {
        currentDistance += intervalMeters;
        final ratio =
            (currentDistance - (segmentEnd - segmentDistance)) /
            segmentDistance;
        final markerPos = _interpolatePoint(points[i - 1], points[i], ratio);
        markers.add(markerPos);
      }

      currentDistance = segmentEnd;
    }

    // Handle closed loop - check if we need markers in the closing segment
    if (loopClosed && points.length >= 3) {
      final closingDistance = _distance.as(
        LengthUnit.Meter,
        points.last,
        points.first,
      );
      final closingEnd = currentDistance + closingDistance;

      while (currentDistance + intervalMeters <= closingEnd) {
        currentDistance += intervalMeters;
        final ratio =
            (currentDistance - (closingEnd - closingDistance)) /
            closingDistance;
        final markerPos = _interpolatePoint(points.last, points.first, ratio);
        markers.add(markerPos);
      }
    }

    return markers;
  }

  /// Interpolate a point between two coordinates
  ///
  /// Calculates a position at the specified ratio between two points.
  /// Used for precise marker placement along route segments.
  LatLng _interpolatePoint(LatLng start, LatLng end, double ratio) {
    final lat = start.latitude + (end.latitude - start.latitude) * ratio;
    final lng = start.longitude + (end.longitude - start.longitude) * ratio;
    return LatLng(lat, lng);
  }

  /// Calculate total route distance
  ///
  /// Sums all segment distances to get the total route length in meters.
  double getTotalDistance() {
    return segmentMeters.fold(0.0, (sum, distance) => sum + distance);
  }

  /// Load route from external data
  ///
  /// Replaces current route with new data and recalculates all derived values.
  /// Useful for importing routes from saved data or file imports.
  void loadRoute(List<LatLng> newPoints, bool isLoopClosed) {
    setState(() {
      routePoints.clear();
      distanceMarkers.clear();
      routePoints.addAll(newPoints);
      segmentMeters.clear();
      ref.read(editingIndexProvider.notifier).state = null;
      ref.read(routeNotifierProvider.notifier).setLoopClosed(isLoopClosed);

      // Recalculate segment distances
      for (int i = 1; i < routePoints.length; i++) {
        segmentMeters.add(
          _distance.as(LengthUnit.Meter, routePoints[i - 1], routePoints[i]),
        );
      }

      // Add closing segment distance if loop is closed
      if (isLoopClosed && routePoints.length >= 3) {
        segmentMeters.add(
          _distance.as(LengthUnit.Meter, routePoints.last, routePoints.first),
        );
      }

      autoGenerateDistanceMarkers();
    });
  }

  /// Check if undo is available
  bool get canUndo => undoHistory.isNotEmpty;

  /// Get current route statistics
  Map<String, dynamic> getRouteStats() {
    return {
      'pointCount': routePoints.length,
      'totalDistance': getTotalDistance(),
      'segmentCount': segmentMeters.length,
      'isLoopClosed': ref.read(loopClosedProvider),
      'hasDistanceMarkers': distanceMarkers.isNotEmpty,
    };
  }

  /// Dispose route management resources
  void disposeRouteManagement() {
    undoHistory.clear();
    routePoints.clear();
    segmentMeters.clear();
    distanceMarkers.clear();
  }
}
